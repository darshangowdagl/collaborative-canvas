## Architecture Overview

### Data Flow (Client ↔ Server)
- Client connects to the server via Socket.io (`/socket.io`).
- On connect, the client emits `join`, and the server:
  - Adds the user to the default room (`lobby`)
  - Assigns a color and returns current `users` and drawing `state` via `joined`.
- As users draw:
  - `draw:begin` → server caches in-progress stroke and broadcasts `draw:begin`.
  - `draw:points` → server appends points to the in-progress stroke and broadcasts `draw:points` to others.
  - `draw:end` → server commits the stroke to history and emits `state:commit` with a new revision.
- Undo/Redo:
  - `undo` or `redo` → server updates global history and broadcasts full `state:update`.
- Cursor:
  - Clients throttle `cursor` events; server forwards to other clients in the room.

### Message Protocol
- Client → Server:
  - `join` { name?: string }
  - `cursor` { x: number, y: number }
  - `draw:begin` { id: string, color: string, size: number, tool: 'brush'|'eraser', points: [{x,y}] }
  - `draw:points` { id: string, points: [{x,y}] }
  - `draw:end` { id: string }
  - `undo` | `redo`
- Server → Client:
  - `joined` { user, users, state }
  - `users:update` { users: User[] }
  - `cursor` { userId, x, y }
  - `draw:begin` { id, color, size, tool, userId }
  - `draw:points` { id, points }
  - `state:commit` { committed: { id }, revision }
  - `state:update` { state: { operations, revision } }

### Undo/Redo Strategy
- The server keeps an authoritative `operations` stack and a `redoStack`.
- On `undo`, the last operation is moved to `redoStack` and `state:update` is broadcast.
- On `redo`, the last item from `redoStack` is restored and `state:update` is broadcast.
- Clients redraw the entire history upon `state:update` for consistency.

### Conflict Resolution
- The server is the single source of truth for committed history.
- In-progress strokes are identified by unique `id` generated by clients.
- If clients miss live segments, subsequent full updates (e.g., after undo/redo) correct visual state.

### Performance Optimizations
- Client throttles `cursor` updates to ~30ms.
- Drawing uses local interpolation for smooth strokes, sending small segments in `draw:points`.
- Canvas redraws full history only on `state:update` (undo/redo), avoiding full redraw per segment.
- Device pixel ratio aware canvas scaling for crisp rendering.

### Scalability
- The `RoomsManager` can be extended to multiple rooms by mapping sockets to room IDs.
- For many users:
  - Backing store for operations (e.g., Redis) to share state across server instances.
  - Event batching and delta-syncs for operations instead of full-state updates.
  - Cursor events could be sent over a separate, lower-priority channel or sample rate reduced.

## Tools & Notes
- Built with: Node.js, Express, Socket.io, HTML5 Canvas, Vanilla JavaScript.
- Development helpers: I used Cursor/GPT to scaffold initial project files and to get advice on architecture. I implemented the main drawing logic, undo/redo, conflict resolution, and UI refinements myself and tested the system locally.
